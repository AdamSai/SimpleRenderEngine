<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>SRE API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight, .highlight .w {
  color: #f8f8f2;
  background-color: #272822;
}
.highlight .err {
  color: #151515;
  background-color: #ac4142;
}
.highlight .c, .highlight .cd, .highlight .cm, .highlight .c1, .highlight .cs {
  color: #505050;
}
.highlight .cp {
  color: #f4bf75;
}
.highlight .nt {
  color: #f4bf75;
}
.highlight .o, .highlight .ow {
  color: #d0d0d0;
}
.highlight .p, .highlight .pi {
  color: #d0d0d0;
}
.highlight .gi {
  color: #90a959;
}
.highlight .gd {
  color: #ac4142;
}
.highlight .gh {
  color: #6a9fb5;
  background-color: #151515;
  font-weight: bold;
}
.highlight .k, .highlight .kn, .highlight .kp, .highlight .kr, .highlight .kv {
  color: #aa759f;
}
.highlight .kc {
  color: #d28445;
}
.highlight .kt {
  color: #d28445;
}
.highlight .kd {
  color: #d28445;
}
.highlight .s, .highlight .sb, .highlight .sc, .highlight .sd, .highlight .s2, .highlight .sh, .highlight .sx, .highlight .s1 {
  color: #90a959;
}
.highlight .sr {
  color: #75b5aa;
}
.highlight .si {
  color: #8f5536;
}
.highlight .se {
  color: #8f5536;
}
.highlight .nn {
  color: #f4bf75;
}
.highlight .nc {
  color: #f4bf75;
}
.highlight .no {
  color: #f4bf75;
}
.highlight .na {
  color: #6a9fb5;
}
.highlight .m, .highlight .mf, .highlight .mh, .highlight .mi, .highlight .il, .highlight .mo, .highlight .mb, .highlight .mx {
  color: #90a959;
}
.highlight .ss {
  color: #90a959;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
    <link href="stylesheets/print.css" rel="stylesheet" media="print" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;c++&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" />
      </span>
    </a>
    <div class="tocify-wrapper">
      <img src="images/logo.png" />
        <div class="lang-selector">
              <a href="#" data-language-name="c++">Code examples</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc">
      </div>
        <ul class="toc-footer">
            <li><a href='https://github.com/tripit/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="introduction">Introduction</h1>

<p>The goal of SimpleRenderEngine (SRE) is to provide easy way to get started with graphics 
programming in 2D or 3D without a deep knowledge about the low-level graphics APIs like 
OpenGL, DirectX and Vulkan.</p>

<p>SRE currently depends on Simple Direct Layer 2.x (SDL2), SDL2-image, OpenGL Mathematics (GLM), and OpenGL 3.3 (or higher), and 
runs on both Windows, macOS and Linux.</p>

<p>The project is hosted here: <a href="https://github.com/mortennobel/SimpleRenderEngine">github.com/mortennobel/SimpleRenderEngine</a></p>

<h1 id="install">Install</h1>

<h2 id="prerequisites">Prerequisites:</h2>

<ul>
<li>Install C++ tool chain / IDE (such as Visual Studio 2015 or XCode)</li>
<li>Install CMake ( <a href="https://cmake.org/download/">cmake.org/download/</a> ). <strong>macOS:</strong> first lauch should be performed by right-clicking the .app and selecting open.</li>
</ul>

<h3 id="sdl-2-x-and-sdl-2-0-image">SDL 2.x and SDL 2.0 Image</h3>

<p>Simple DirectMedia Layer is a platform abstraction layer for game development. The 
abstraction makes both single platform and cross platform development easier. The project
has a simple C-interface.</p>

<p>Download <strong>development libraries (not runtime libraries!)</strong> from </p>

<ul>
<li><a href="https://www.libsdl.org/download-2.0.php">www.libsdl.org/download-2.0.php</a></li>
<li><a href="https://www.libsdl.org/projects/SDL_image/">www.libsdl.org/projects/SDL_image/</a></li>
</ul>

<p><strong>Windows:</strong> Extract the zip-files to any folder (e.g. Documents)</p>

<p><strong>macOS:</strong> Open dmg files and copy .frameworks to /Library/Framework</p>

<p>SDL documentation can be found here: <a href="http://wiki.libsdl.org/FrontPage">wiki.libsdl.org/FrontPage</a></p>

<h3 id="glm-opengl-mathematics">GLM (OpenGL Mathematics)</h3>

<p>GLM is a header-only C++ library for linear algebra such as vectors, matrices and quaternions.   </p>

<p>Download project from <a href="http://glm.g-truc.net">glm.g-truc.net</a> and extract to any folder. (e.g. Documents)</p>

<h3 id="glew-the-opengl-extension-wrangler-library">GLEW (The OpenGL Extension Wrangler Library)</h3>

<p><strong>(Windows only)</strong> Enable full OpenGL support for Windows. </p>

<p>Download the <strong>Windows 32-bit and 64-bit</strong> zip-file from http://glew.sourceforge.net/ and extract it to any folder (e.g. Documents).    </p>

<h2 id="download-and-setup-simplerenderengine">Download and setup SimpleRenderEngine</h2>

<p>Clone the repository from <a href="https://github.com/mortennobel/SimpleRenderEngine">github.com/mortennobel/SimpleRenderEngine</a> .</p>

<p>Configure the project using CMake ( / cmake-gui) to VisualStudio/XCode using the following settings:</p>

<p>Tips and comments:</p>

<ul>
<li>Windows : It is recommended that you build the project as <strong>32-bit</strong>.</li>
<li>It is important that you choose the correct </li>
<li>You need to click the configure whenever you have changed a setting. This ensures that all</li>
<li>Documentation for the CMake properties can be found in the cmake/FindXXX.cmake files</li>
<li>It is recommended to GLEW static library (<strong>glew32s.lib</strong>) for windows.</li>
<li>If you have old Visual Studio installation, you might need to change the settings of the Microsoft.Cpp.Win32.user (in the Property Manager)</li>
</ul>

<p><strong>Windows</strong></p>

<p>Notes:</p>

<ul>
<li>The SDL2_Library need to be the full path of both SDL2.lib and SDL2main.lib. Separated with
a semicolon.</li>
</ul>

<p><img title="CMake Mac" alt="alt text" src="images/cmake-windows.png" /></p>

<p><strong>Mac</strong></p>

<p><img title="CMake Mac" alt="alt text" src="images/cmake-mac.png" /></p>

<h1 id="resource-management">Resource management</h1>

<p>SimpleRenderEngine does not provide any automatically resource management. 
It is up the library user (the developer) to destroy any object that is allocated.</p>

<p>Generally objects can be created in three different ways:</p>

<ul>
<li><strong>Constructor</strong>: Object creation using constructor. If the objects are allocated on the heap (using new) they must also be explicit 
deleted when no longer used.</li>
<li><strong>createXXX()</strong>: Object pointers returned from createXXX member functions. These objects are created by
SimpleRenderEngine, but not referenced. These objects should be explicit deleted when
no longer used.</li>
<li><strong>getXXX()</strong>: Object pointers returned from getXXX member functions. The ownership of these objects are maintained by 
SimpleRenderEngine. These objects should not be deleted.</li>
</ul>

          <h1 id="simplerenderengine">SimpleRenderEngine</h1>

<p><code class="prettyprint">#include &quot;sre/Renderer.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="c1">// Example (hello-engine.cpp):
</span><span class="n">SDL_Window</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
<span class="n">SDL_Init</span><span class="p">(</span><span class="n">SDL_INIT_VIDEO</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_MAJOR_VERSION</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_MINOR_VERSION</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="n">SDL_GL_SetAttribute</span><span class="p">(</span><span class="n">SDL_GL_CONTEXT_PROFILE_MASK</span><span class="p">,</span> <span class="n">SDL_GL_CONTEXT_PROFILE_CORE</span><span class="p">);</span>
<span class="n">window</span> <span class="o">=</span> <span class="n">SDL_CreateWindow</span><span class="p">(</span><span class="s">"Hello Engine"</span><span class="p">,</span><span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span><span class="n">SDL_WINDOWPOS_UNDEFINED</span><span class="p">,</span><span class="mi">640</span><span class="p">,</span><span class="mi">480</span><span class="p">,</span><span class="n">SDL_WINDOW_OPENGL</span><span class="p">);</span>
<span class="n">Renderer</span> <span class="n">r</span><span class="p">{</span><span class="n">window</span><span class="p">};</span>
<span class="n">RenderPass</span> <span class="n">rp</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">createRenderPass</span><span class="p">().</span><span class="n">build</span><span class="p">();</span>
<span class="n">rp</span><span class="p">.</span><span class="n">drawLines</span><span class="p">({{</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">},{</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">}});</span>
<span class="n">r</span><span class="p">.</span><span class="n">swapWindow</span><span class="p">();</span>
<span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">10000</span><span class="p">);</span>
<span class="n">SDL_DestroyWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
<span class="n">SDL_Quit</span><span class="p">();</span>
</code></pre>

<p>Maintains rendering context.
An object of Renderer must be created once after the SDL_Window has been initialized.
After initialization this object can be referenced using the static field Renderer::instance;</p>

<p>A renderer can use one or more renderpasses before calling swapWindow()</p>

<h2 id="renderer">Renderer</h2>

<p><code class="prettyprint">Renderer(SDL_Window *window)</code></p>

<p>Renderer constructor</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>window</td>
<td>window pointer to the SDL window (must be initialized using OpenGL)</td>
</tr>
</tbody></table>

<h2 id="createrenderpass">createRenderPass</h2>

<p><code class="prettyprint">RenderPass::RenderPassBuilder createRenderPass()</code></p>

<p>Usage:</p>

<p><code class="prettyprint">class RenderPassBuilder {
public:
RenderPassBuilder&amp; withName(const std::string&amp; name);
RenderPassBuilder&amp; withCamera(const Camera&amp; camera);
RenderPassBuilder&amp; withWorldLights(WorldLights* worldLights);
RenderPassBuilder&amp; withClearColor(bool enabled = true,glm::vec4 color = {0,0,0,1});
RenderPassBuilder&amp; withClearDepth(bool enabled = true, float value = 1);
RenderPassBuilder&amp; withClearStencil(bool enabled = false, int value = 0);
RenderPassBuilder&amp; withGUI(bool enabled = true);
RenderPass build();
}</code></p>

<p>The RenderPassBuilder creates a renderpass using the builder pattern.
Camera should always be defined (otherwise a default camera is used: orthographic with size 1.0).
If lights is used (for 3D scenes) then the WorldLights need to be defined.
The default behaviour is to clear color and depth buffer. This can be changed by using withClearXXX member functions.
Another default behavior is GUI is expected, which allows ImGUI calls after the renderpass has been called.
Finally, build need to be called to create the RenderPass object.</p>

<h2 id="swapwindow">swapWindow</h2>

<p><code class="prettyprint">void swapWindow()</code></p>

<p>Update window with OpenGL rendering by swapping buffers</p>

<h2 id="getwindowsize">getWindowSize</h2>

<p><code class="prettyprint">glm::ivec2 getWindowSize()</code></p>

<p>Return the current size of the window.</p>

<h2 id="finishgpucommandbuffer">finishGPUCommandBuffer</h2>

<p><code class="prettyprint">void finishGPUCommandBuffer()</code></p>

<p>GPU command buffer (must be called when profiling GPU time - should not be called when not profiling)</p>

<h2 id="getrenderstats">getRenderStats</h2>

<p><code class="prettyprint">const RenderStats&amp; getRenderStats()</code></p>

<p>Return stats of the last rendered frame
RenderStats only includes data maintained by SRE (imgui is not included)</p>

<h2 id="instance">instance</h2>

<p><code class="prettyprint">static SimpleRenderEngine* instance</code></p>

<p>Singleton reference to the engine after initialization.</p>

          <h1 id="renderpass">RenderPass</h1>

<p>See Renderer.createRenderPass() for initialization.</p>

<h2 id="draw">draw</h2>

<p><code class="prettyprint">void draw(std::shared_ptr&lt;Mesh&gt;&amp; mesh, glm::mat4 modelTransform, std::shared_ptr&lt;Material&gt;&amp; material)</code></p>

<p>Draws a mesh using the given transform and material.</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>mesh</td>
<td>The mesh to draw</td>
</tr>
<tr>
<td>modelTransform</td>
<td>The local to world transformation (usually composed of translations, rotations and scales)</td>
</tr>
<tr>
<td>material</td>
<td>The material used for rendering</td>
</tr>
</tbody></table>

<h2 id="drawlines">drawLines</h2>

<p><code class="prettyprint">void drawLines(const std::vector&lt;glm::vec3&gt; &amp;verts, glm::vec4 color = {1.0f, 1.0f, 1.0f, 1.0f}, MeshTopology meshTopology = MeshTopology::LineStrip)</code></p>

<p>Draws world-space lines - using the unlit shader.
Note that this member function is not expected to perform as efficient as draw()</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>verts</td>
<td>The mesh to draw</td>
</tr>
<tr>
<td>color</td>
<td>The color of the lines (default: {1.0f, 1.0f, 1.0f, 1.0f})</td>
</tr>
<tr>
<td>meshTopology</td>
<td>The mesh topology (default: MeshTopology::LineStrip)</td>
</tr>
</tbody></table>

          <h1 id="sdlrenderer">SDLRenderer</h1>

<p><code class="prettyprint">#include &quot;sre/SDLRenderer.hpp&quot;</code></p>

<p>Simplifies SDL applications by abstracting away boilerplate code. </p>

<p>SDLRenderer is a pure helper-class, and no other class in the SimpleRenderEngine depends on it. </p>

<p>The class will create a window with a graphics context in the <code class="prettyprint">init()</code> member function.
The <code class="prettyprint">startEventLoop()</code> will start the event loop, which polls the event queue in the 
beginning of each frame (and providing callbacks to <code class="prettyprint">keyEvent</code> and <code class="prettyprint">mouseEvent</code>), followed by a <code class="prettyprint">frameUpdate(float)</code> and a <code class="prettyprint">frameRender(Renderer)</code>.</p>

<p>Example:</p>
<pre class="highlight plaintext"><code>#include "sre/SDLRenderer.hpp"

using namespace sre;
using namespace std;

int main() {
    SDLRenderer r;
    r.init();
    r.frameRender = [](Renderer* renderer){
        RenderPass rp = renderer-&gt;createRenderPass().build();
        rp.drawLines({{-.5,-.5,0},{.5,.5,0},{-.5,.5,0},{.5,-.5,0}});
    };
    r.startEventLoop();

    return 0;
}
</code></pre>

<h2 id="sdlrenderer">SDLRenderer</h2>

<p><code class="prettyprint">SDLRenderer</code></p>

<p>Constructor.</p>

<h2 id="setwindowtitle">setWindowTitle</h2>

<p><code class="prettyprint">void setWindowTitle(std::string title)</code></p>

<p>Set the window title. If window has already been created the window title is set instantly - 
otherwise the new title will be used when creating the window. </p>

<h2 id="setwindowsize">setWindowSize</h2>

<p><code class="prettyprint">void setWindowSize(int width, int height)</code></p>

<p>Set the window size. If window has already been created the window size is set instantly - 
otherwise the new size will be used when creating the window.</p>

<h2 id="init">init</h2>

<p><code class="prettyprint">void init(uint32_t sdlInitFlag = SDL_INIT_EVERYTHING)</code></p>

<p>Create the window and the graphics context (instantiates the sre::Renderer). Note that most 
other sre classes requires the graphics content to be created before they can be used (e.g. a Shader cannot be created before <code class="prettyprint">init()</code>).</p>

<p>The parameter sdlInitFlag is forwarded to SDL_Init. For production only modules needed should be initialized. See <a href="https://wiki.libsdl.org/SDL_Init">wiki.libsdl.org/SDL_Init</a></p>

<h2 id="frameupdate">frameUpdate</h2>

<p><code class="prettyprint">std::function&lt;void(float deltaTimeSec)&gt; frameUpdate</code></p>

<p>Subscribe to update events from the main loop used for updating the model with the number of seconds since last update.</p>
<pre class="highlight plaintext"><code>// Example - use frameUpdate callback to print delta time
SDLRenderer r;
r.init();
r.frameUpdate = [](float deltaTime){
    cout &lt;&lt; deltaTime &lt;&lt; endl;
};
// ...
</code></pre>

<h2 id="framerender">frameRender</h2>

<p><code class="prettyprint">std::function&lt;void(Renderer* renderer)&gt; frameRender</code></p>

<p>Subscript be render events. The <code class="prettyprint">Renderer::swapFrame()</code> is automatically invoked after the callback.</p>

<h2 id="keyevent">keyEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; keyEvent</code></p>

<p>Call back of <code class="prettyprint">SDL_KEYDOWN</code> and <code class="prettyprint">SDL_KEYUP</code>.</p>

<h2 id="mouseevent">mouseEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; keyEvent</code></p>

<p>Call back of <code class="prettyprint">SDL_MOUSEMOTION</code>, <code class="prettyprint">SDL_MOUSEBUTTONDOWN</code>, <code class="prettyprint">SDL_MOUSEBUTTONUP</code>, <code class="prettyprint">SDL_MOUSEWHEEL</code>.</p>

<h2 id="controllerevent">controllerEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; controllerEvent</code></p>

<p>Call back of <code class="prettyprint">SDL_CONTROLLERAXISMOTION</code>, <code class="prettyprint">SDL_CONTROLLERBUTTONDOWN</code>, <code class="prettyprint">SDL_CONTROLLERBUTTONUP</code>, <code class="prettyprint">SDL_CONTROLLERDEVICEADDED</code>, <code class="prettyprint">SDL_CONTROLLERDEVICEREMOVED</code> and <code class="prettyprint">SDL_CONTROLLERDEVICEREMAPPED</code>.</p>

<h2 id="joystickevent">joystickEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; joystickEvent</code></p>

<p>Call back of <code class="prettyprint">SDL_JOYAXISMOTION</code>, <code class="prettyprint">SDL_JOYBALLMOTION</code>, <code class="prettyprint">SDL_JOYHATMOTION</code>, <code class="prettyprint">SDL_JOYBUTTONDOWN</code>, <code class="prettyprint">SDL_JOYBUTTONUP</code>, <code class="prettyprint">SDL_JOYDEVICEADDED</code>, <code class="prettyprint">SDL_JOYDEVICEREMOVED</code>.</p>

<h2 id="touchevent">touchEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; touchEvent</code></p>

<p>Call back of <code class="prettyprint">SDL_FINGERDOWN</code>, <code class="prettyprint">SDL_FINGERUP</code>, <code class="prettyprint">SDL_FINGERMOTION</code>.</p>

<h2 id="otherevent">otherEvent</h2>

<p><code class="prettyprint">std::function&lt;void(SDL_Event&amp; e)&gt; otherEvent</code></p>

<p>Invoked if unhandled event</p>

<h2 id="starteventloop">startEventLoop</h2>

<p><code class="prettyprint">void startEventLoop()</code></p>

<p>Start the event loop. Note that this member function in usually blocking (until the <code class="prettyprint">stopEventLoop()</code> has been called). 
Using Emscripten the event loop is not blocking (but internally using a callback function), which means that when using 
Emscripten avoid allocating objects on the stack (see examples for a workaround).</p>

<h2 id="stopeventloop">stopEventLoop</h2>

<p><code class="prettyprint">void stopEventLoop()</code></p>

<p>The render loop will stop running when the frame is complete.</p>

<h2 id="getsdlwindow">getSDLWindow</h2>

<p><code class="prettyprint">SDL_Window *getSDLWindow()</code></p>

<p>Returns a pointer to <code class="prettyprint">SDL_Window</code>.</p>

          <h1 id="texture">Texture</h1>

<p><code class="prettyprint">#include &quot;sre/Texture.hpp&quot;</code></p>

<p>Represent a texture (uploaded to the GPU).
In general the width and the height of the texture should be power-of-two (e.g. 256 or 512).</p>

<p>Textures can be created from files (png). Alternative textures can be created using memory representation
of the texture in RGB/RGBA (one byte per color channel).</p>

<p>The Texture class also provides a white texture using the Texture::getWhiteTexture()</p>

<p>A texture object has the following properties:</p>

<ul>
<li>mipmaps enabled: Optimization, where the texture exists in downscaled versions. This does use more memory, but
in general gives faster texture sampling.</li>
<li>wrap texture coordinates: if enabled the texture is repeated when sampling out the 0.0 .. 1.0 values</li>
<li>filter sampling: if enabled the texture sampling will use interpolation to find the colors between pixel centers</li>
</ul>

<h2 id="create">create</h2>

<p><code class="prettyprint">static TextureBuilder create()</code></p>

<p>Creates a texture using the builder pattern. 
TextureBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>TextureBuilder&amp; withGenerateMipmaps(bool enable);
// if true texture sampling is filtered (bi-linear or tri-linear sampling) otherwise use point sampling.
TextureBuilder&amp; withFilterSampling(bool enable);
TextureBuilder&amp; withWrappedTextureCoordinates(bool enable);
TextureBuilder&amp; withFileCubemap(const char *filename, TextureCubemapSide side);
TextureBuilder&amp; withFile(const char *filename);
TextureBuilder&amp; withRGBData(const char* data, int width, int height);
TextureBuilder&amp; withRGBAData(const char* data, int width, int height);
TextureBuilder&amp; withWhiteData(int width=2, int height=2);
std::shared_ptr&lt;Texture&gt; build();
</code></pre>

<h2 id="getwhitetexture">getWhiteTexture</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Texture&gt; getWhiteTexture()</code></p>

<h2 id="getspheretexture">getSphereTexture</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Texture&gt; getSphereTexture()</code></p>

<h2 id="getdefaultcubemaptexture">getDefaultCubemapTexture</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Texture&gt; getDefaultCubemapTexture()</code></p>

<h2 id="getwidth">getWidth</h2>

<p><code class="prettyprint">int getWidth()</code></p>

<h2 id="getheight">getHeight</h2>

<p><code class="prettyprint">int getHeight()</code></p>

<h2 id="isfiltersampling">isFilterSampling</h2>

<p><code class="prettyprint">bool isFilterSampling()</code></p>

<p>returns true if texture sampling is filtered when sampling (bi-linear or tri-linear sampling).</p>

<h2 id="iswraptexturecoordinates">isWrapTextureCoordinates</h2>

<p><code class="prettyprint">bool isWrapTextureCoordinates()</code></p>

<h2 id="iscubemap">isCubemap</h2>

<p><code class="prettyprint">bool isCubemap()</code></p>

<h2 id="getdatasize">getDataSize</h2>

<p><code class="prettyprint">int getDataSize()</code></p>

<p>get size of the texture in bytes on GPU</p>

          <h1 id="shader">Shader</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>

<p>Controls the appearance of the rendered objects.</p>

<p>The shader also controls depth test, depth write and blending.</p>

<p>There is the following premade shaders:
- Shader::getStandard()
   - Shades the mesh using the Phong light model, and uses the current light states and camera states as well as
     the color and texture parameters
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getUnlit()
   - Uses the camera states as well as the color and texture parameters to define the surface color
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getUnlitSprite()
   - Similar to getUnlit() but with no depth write
   - Parameters:
     - color (vec4) (default white)
     - tex (shared_ptr<Texture>) (default white texture)
- Shader::getStandardParticles()
   - Similar to getUnlit() but with no depth write
   - Parameters:
     - tex (shared_ptr<Texture>) (default alpha sphere texture)</p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static ShaderBuilder create();</code></p>

<p>Creates a shader using the builder pattern. 
ShaderBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>ShaderBuilder&amp; withSource(const char* vertexShaderGLSL, const char* fragmentShaderGLSL);
ShaderBuilder&amp; withSourceStandard();
ShaderBuilder&amp; withSourceUnlit();
ShaderBuilder&amp; withSourceUnlitSprite();
ShaderBuilder&amp; withSourceStandardParticles();
ShaderBuilder&amp; withSourceDebugUV();
ShaderBuilder&amp; withSourceDebugNormals();
ShaderBuilder&amp; widthDepthTest(bool enable);
ShaderBuilder&amp; withDepthTest(bool enable);
ShaderBuilder&amp; withDepthWrite(bool enable);
ShaderBuilder&amp; withBlend(BlendType blendType);
std::shared_ptr&lt;Shader&gt; build();
</code></pre>

<h2 id="getstandard">getStandard</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getStandard()</code></p>

<h2 id="getunlit">getUnlit</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getUnlit()</code></p>

<h2 id="getunlitsprite">getUnlitSprite</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getUnlitSprite()</code></p>

<h2 id="getstandardparticles">getStandardParticles</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getStandardParticles()</code></p>

<h2 id="getdebuguv">getDebugUV</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getDebugUV()</code></p>

<p>Shader for visualizing texture coordinates on mesh(UVs)</p>

<h2 id="getdebugnormals">getDebugNormals</h2>

<p><code class="prettyprint">static std::shared_ptr&lt;Shader&gt; getDebugNormals()</code></p>

<p>Shader for visualizing mesh normals.</p>

<h2 id="creatematerial">createMaterial</h2>

<p><code class="prettyprint">std::shared_ptr&lt;Material&gt; createMaterial()</code></p>

<p>Create a material instance with the current shader.</p>

<h2 id="contains">contains</h2>

<p><code class="prettyprint">bool contains(const char* name)</code></p>

<p>Return if the shader contains a uniform with a given name.</p>

<h2 id="gettype">getType</h2>

<p><code class="prettyprint">Uniform getType(const char* name)</code></p>

<p>Returns uniform information with a uniform of a given name.</p>

<h2 id="isdepthtest">isDepthTest</h2>

<p><code class="prettyprint">bool isDepthTest()</code></p>

<h2 id="isdepthwrite">isDepthWrite</h2>

<p><code class="prettyprint">bool isDepthWrite()</code></p>

<h2 id="getblend">getBlend</h2>

<p><code class="prettyprint">BlendType getBlend()</code></p>

<h2 id="getattributenames">getAttributeNames</h2>

<p><code class="prettyprint">std::vector&lt;std::string&gt; getAttributeNames()</code></p>

<h2 id="getuniformnames">getUniformNames</h2>

<p><code class="prettyprint">std::vector&lt;std::string&gt; getUniformNames()</code></p>

<h2 id="validatemesh">validateMesh</h2>

<p>Validates the mesh attributes. If invalid, then set info variable to error message.
This method should be used for debug purpose only</p>

<p><code class="prettyprint">bool validateMesh(Mesh* mesh, std::string &amp; info)</code></p>

          <h1 id="mesh">Mesh</h1>

<p><code class="prettyprint">#include &quot;sre/Mesh.hpp&quot;</code></p>

<p>Represents a Mesh object.
A mesh is composed of a list of</p>

<ul>
<li>vertexPositions (vec3)</li>
<li>normals (vec3)</li>
<li>uvs (aka. texture coordinates) (vec2)</li>
</ul>

<p>A mesh also has a meshType, which can be either: 
 - MeshTopology::Points 
 - MeshTopology::Lines
 - MeshTopology::Triangles</p>

<p>The mesh is defined based on the order of vertices, when the indices is empty. 
Otherwise the indices is used to define the mesh. </p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static MeshBuilder create();</code></p>

<p>Creates a mesh using the builder pattern. 
MeshBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>MeshBuilder&amp; withSphere(int stacks = 16, int slices = 32, float radius = 1);
MeshBuilder&amp; withCube(float length = 1);
MeshBuilder&amp; withQuad();
MeshBuilder&amp; withPositions(const std::vector&lt;glm::vec3&gt; &amp;vertexPositions);
MeshBuilder&amp; withNormals(const std::vector&lt;glm::vec3&gt; &amp;normals);
MeshBuilder&amp; withUVs(const std::vector&lt;glm::vec4&gt; &amp;uvs);
MeshBuilder&amp; withColors(const std::vector&lt;glm::vec4&gt; &amp;colors);
MeshBuilder&amp; withParticleSizes(const std::vector&lt;float&gt; &amp;particleSize);
MeshBuilder&amp; withMeshTopology(MeshTopology meshTopology);
MeshBuilder&amp; withIndices(const std::vector&lt;uint16_t&gt; &amp;indices);
std::shared_ptr&lt;Mesh&gt; build();
</code></pre>

<h2 id="update">update</h2>

<p><code class="prettyprint">MeshBuilder update()</code></p>

<p>Updates a mesh using the builder pattern.
See Mesh::create().
Performance-wise it is more efficient to update an existing mesh than to create a new mesh.</p>

<h2 id="getvertexcount">getVertexCount</h2>

<p><code class="prettyprint">int getVertexCount()</code></p>

<h2 id="getmeshtopology">getMeshTopology</h2>

<p><code class="prettyprint">MeshTopology getMeshTopology()</code></p>

<h2 id="getpositions">getPositions</h2>

<p><code class="prettyprint">const std::vector&lt;glm::vec3&gt;&amp; getPositions()</code></p>

<h2 id="getnormals">getNormals</h2>

<p><code class="prettyprint">const std::vector&lt;glm::vec3&gt;&amp; getNormals()</code></p>

<h2 id="getuvs">getUVs</h2>

<p><code class="prettyprint">const std::vector&lt;glm::vec2&gt;&amp; getUVs()</code></p>

<h2 id="getcolors">getColors</h2>

<p><code class="prettyprint">const std::vector&lt;glm::vec4&gt;&amp; getColors()</code></p>

<h2 id="getparticlesizes">getParticleSizes</h2>

<p><code class="prettyprint">const std::vector&lt;float&gt;&amp; getParticleSizes()</code></p>

<h2 id="getindices">getIndices</h2>

<p><code class="prettyprint">const std::vector&lt;uint16_t&gt;&amp; getIndices()</code></p>

          <h1 id="camera">Camera</h1>

<p><code class="prettyprint">#include &quot;sre/Camera.hpp&quot;</code></p>

<p>The camera contains two important properties:
- <strong>view transform matrix</strong>: Contains information about location and orientation of the camera. This matrix will
transform geometry from world space to eye space.
- <strong>projection transform matrix</strong>: Contains information about the projection the camera uses (roughly equivalent to
which lens it uses). Generally this can either be perspective projection (with a field of view) or a orthographic
projection (without any perspective).</p>

<p>The camera also includes information about the viewport, which defines which part of the window is used for
rendering (default settings is the full window)</p>

<p>The default camera is positioned at (0,0,0) and looking down the negative z-axis. Everything inside the volume
between -1 to 1 is viewed.</p>

<p>Note that if the window size is resized the camera must explicit be updated using <code class="prettyprint">setViewport</code>,
<code class="prettyprint">setPerspectiveProjection</code>/<code class="prettyprint">setWindowCoordinates</code></p>

<h2 id="camera">Camera</h2>

<p><code class="prettyprint">Camera()</code></p>

<p>Constructor</p>

<p>Set camera at (0,0,0) looking down the negative z-axis using orthographic viewing volume between -1 to 1</p>

<h2 id="lookat">lookAt</h2>

<p><code class="prettyprint">void lookAt(glm::vec3 eye, glm::vec3 at, glm::vec3 up)</code></p>

<p>set position of camera in world space using</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>eye</td>
<td>position of the camera</td>
</tr>
<tr>
<td>at</td>
<td>position that the camera looks at (must be different from pos)</td>
</tr>
<tr>
<td>up</td>
<td>the up axis (used for rotating camera around z-axis). Must not be parallel with view direction (at - pos).</td>
</tr>
</tbody></table>

<h2 id="setperspectiveprojection">setPerspectiveProjection</h2>

<p><code class="prettyprint">void setPerspectiveProjection(float fieldOfViewY, float viewportWidth,float viewportHeight, float nearPlane, float farPlane)</code></p>

<p>set the projectionTransform to perspective projection.</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>fieldOfViewY</td>
<td>field of view in degrees</td>
</tr>
<tr>
<td>nearPlane</td>
<td>near clipping plane, defines how close an object can be to the camera before clipping (must be positive)</td>
</tr>
<tr>
<td>farPlane</td>
<td>far clipping plane, defines how far an object can be to the camera before clipping (must be larger than nearPlane)</td>
</tr>
</tbody></table>

<h2 id="setorthographicprojection">setOrthographicProjection</h2>

<p><code class="prettyprint">void setOrthographicProjection(float left, float right, float  bottom, float top, float zNear, float zFar)</code></p>

<p>set the projectionTransform to orthographic parallel viewing volume.</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>left</td>
<td>left plane of projection</td>
</tr>
<tr>
<td>right</td>
<td>right plane of projection</td>
</tr>
<tr>
<td>bottom</td>
<td>bottom plane of projection</td>
</tr>
<tr>
<td>top</td>
<td>top plane of projection</td>
</tr>
<tr>
<td>nearPlane</td>
<td>near clipping plane, defines how close an object can be to the camera before clipping</td>
</tr>
<tr>
<td>farPlane</td>
<td>far clipping plane, defines how far an object can be to the camera before clipping</td>
</tr>
</tbody></table>

<h2 id="setwindowcoordinates">setWindowCoordinates</h2>

<p><code class="prettyprint">void setWindowCoordinates(int width = -1, int height = -1)</code></p>

<p>set orthographic transform and view, where the origin is located in the lower left corner.
z depth is between -1 and 1.</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>width</td>
<td>the width of the window, if -1 uses current window size</td>
</tr>
<tr>
<td>height</td>
<td>the height of the window, if -1 uses current window size</td>
</tr>
</tbody></table>

<h2 id="setviewtransform">setViewTransform</h2>

<p><code class="prettyprint">void setViewTransform(const glm::mat4 &amp;viewTransform)</code></p>

<p>Set the view transform. Used to position the virtual camera position and orientation. </p>

<h2 id="setprojectiontransform">setProjectionTransform</h2>

<p><code class="prettyprint">void setProjectionTransform(const glm::mat4 &amp;projectionTransform)</code></p>

<p>Set the projection transform. Defines the view volume and how it is projected to the screen.</p>

<h2 id="getviewtransform">getViewTransform</h2>

<p><code class="prettyprint">glm::mat4 getViewTransform()</code></p>

<p>Get the view transform. The matrix transformation contain the orientation and position of the virtual camera.</p>

<h2 id="getprojectiontransform">getProjectionTransform</h2>

<p><code class="prettyprint">glm::mat4 getProjectionTransform()</code></p>

<p>Get the projection transform  - used for rendering</p>

<h2 id="setviewport">setViewport</h2>

<p><code class="prettyprint">void setViewport(int x, int y, int width, int height)</code></p>

<p>defines which part of the window is used for
rendering (default settings is the full window)</p>

<table><thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>x</td>
<td>the x coordinate of the viewport (default 0)</td>
</tr>
<tr>
<td>y</td>
<td>the y coordinate of the viewport (default 0)</td>
</tr>
<tr>
<td>width</td>
<td>the width of the viewport (default window width)</td>
</tr>
<tr>
<td>height</td>
<td>the height of the viewport (default window height)</td>
</tr>
</tbody></table>

          <h1 id="light">Light</h1>

<p><code class="prettyprint">#include &quot;sre/Light.hpp&quot;</code></p>

<p>Contains information about a Light source</p>

<h2 id="create">create</h2>

<p><code class="prettyprint">static LightBuilder create()</code></p>

<p>Creates a light using builder pattern. 
LightBuilder object has following member functions:</p>
<pre class="highlight plaintext"><code>LightBuilder&amp; withPointLight(glm::vec3 position);
LightBuilder&amp; withDirectionalLight(glm::vec3 direction);
LightBuilder&amp; withColor(glm::vec3 color);
LightBuilder&amp; withRange(float range);
Light build();
</code></pre>

<h2 id="light">Light</h2>

<p><code class="prettyprint">Light()</code></p>

<p>Constructor</p>

<h2 id="lighttype">lightType</h2>

<p><code class="prettyprint">LightType lightType</code></p>

<p>Defines the type of light source (note: ambient light is stored as a vec3 directly in SimpleRenderEngine)</p>

<ul>
<li>LightType::Point,</li>
<li>LightType::Directional,</li>
<li>LightType::Unused</li>
</ul>

<h2 id="position">position</h2>

<p><code class="prettyprint">glm::vec3 position</code></p>

<p>position in worldspace
only used for point lights</p>

<h2 id="direction">direction</h2>

<p><code class="prettyprint">glm::vec3 direction</code></p>

<p>direction towards the lightsource
only used for directional light</p>

<h2 id="color">color</h2>

<p><code class="prettyprint">glm::vec3 color</code></p>

<p>The color (or intensity) of the light
In the light color may have values above 1.0</p>

<h2 id="range">range</h2>

<p><code class="prettyprint">float range</code></p>

<p>The range of a point light (due to attenuation)
Range == 0 means no attenuation</p>

          <h1 id="blendtype">BlendType</h1>

<p><code class="prettyprint">#include &quot;sre/Blendtype.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">BlendType</span> <span class="p">{</span>
    <span class="n">Disabled</span><span class="p">,</span>
    <span class="n">AlphaBlending</span><span class="p">,</span>
    <span class="n">AdditiveBlending</span>
<span class="p">};</span>
</code></pre>

<p>Enum which defines blending types. Currently support types of blending is:</p>

<ul>
<li>BlendType::Disabled - no blending</li>
<li>BlendType::AlphaBlending - Blends the surface with background based on alpha value (src alpha ,one minus src alpha)</li>
<li>BlendType::AdditiveBlending - Add light based on the alpha value (src alpha,one)</li>
</ul>

          <h1 id="lighttype">LightType</h1>

<p><code class="prettyprint">#include &quot;sre/LightType.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">LightType</span> <span class="p">{</span>
    <span class="n">Point</span><span class="p">,</span>
    <span class="n">Directional</span><span class="p">,</span>
    <span class="n">Unused</span>
<span class="p">};</span>
</code></pre>

<p>Defines the types of Light. Note ambient light is simply represented using a vec3 in the SimpleRenderEngine class.</p>

          <h1 id="meshtopology">MeshTopology</h1>

<p><code class="prettyprint">#include &quot;sre/MeshTopology.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">MeshTopology</span> <span class="p">{</span>
    <span class="n">Points</span><span class="p">,</span>
    <span class="n">Lines</span><span class="p">,</span>
    <span class="n">LineStrip</span><span class="p">,</span>
    <span class="n">Triangles</span><span class="p">,</span>
    <span class="n">TriangleStrip</span><span class="p">,</span>
    <span class="n">TriangleFan</span>
<span class="p">};</span>
</code></pre>

<p>Mesh topology used to define the type of mesh</p>

          <h1 id="uniform">Uniform</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">struct</span> <span class="n">Uniform</span> <span class="p">{</span>
    <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">[</span><span class="mi">50</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
    <span class="n">UniformType</span> <span class="n">type</span><span class="p">;</span>
    <span class="c1">// 1 means not array
</span>    <span class="kt">int</span> <span class="n">arraySize</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>

<p>Defines the structure of a shader uniform</p>

          <h1 id="uniformtype">UniformType</h1>

<p><code class="prettyprint">#include &quot;sre/Shader.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">UniformType</span> <span class="p">{</span>
    <span class="n">Int</span><span class="p">,</span>
    <span class="n">Float</span><span class="p">,</span>
    <span class="n">Mat3</span><span class="p">,</span>
    <span class="n">Mat4</span><span class="p">,</span>
    <span class="n">Vec4</span><span class="p">,</span>
    <span class="n">Texture</span><span class="p">,</span>
    <span class="n">TextureCube</span><span class="p">,</span>
    <span class="n">Invalid</span>
<span class="p">};</span>
</code></pre>

<p>Defines variable types for shader uniforms</p>

          <h1 id="renderstats">RenderStats</h1>

<p><code class="prettyprint">#include &quot;sre/RenderStats.hpp&quot;</code></p>
<pre class="highlight cpp"><code><span class="k">struct</span> <span class="n">RenderStats</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">frame</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">meshCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">meshBytes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">textureCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">textureBytes</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">shaderCount</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">drawCalls</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesShader</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesMaterial</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">stateChangesMesh</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>

<p>Contains information about the last frame</p>

          <h1 id="imgui_sre">ImGui_SRE</h1>

<p><code class="prettyprint">#include &quot;sre/imgui_sre.hpp&quot;</code></p>

<p>The ImGUI library is included in SRE.</p>

<p>The Github project: <a href="https://github.com/ocornut/imgui">github.com/ocornut/imgui</a></p>

<p>Documentation: </p>

<ul>
<li><a href="https://github.com/ocornut/imgui/blob/master/imgui.h">github.com/ocornut/imgui/blob/master/imgui.h</a></li>
<li><a href="https://github.com/ocornut/imgui/blob/master/imgui_demo.cpp">github.com/ocornut/imgui/blob/master/imgui_demo.cpp</a></li>
</ul>

<h2 id="imgui_sre_processevent">ImGui_SRE_ProcessEvent</h2>

<p><code class="prettyprint">bool        ImGui_SRE_ProcessEvent(SDL_Event *event);</code></p>

<p>ImGui_SRE_ProcessEvent must be invoked in the beginning of each frame before any other ImGui calls to capture events from SDL.</p>
<pre class="highlight cpp"><code>    <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit</span><span class="p">){</span>
        <span class="c1">//Handle events on queue
</span>        <span class="k">while</span><span class="p">(</span> <span class="n">SDL_PollEvent</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">e</span> <span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ImGui_SRE_ProcessEvent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">SDL_QUIT</span><span class="p">)</span>
                <span class="n">quit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">auto</span> <span class="n">renderPass</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">createRenderPass</span><span class="p">()</span>
                <span class="p">.</span><span class="n">withCamera</span><span class="p">(</span><span class="n">camera</span><span class="p">)</span>
                <span class="p">.</span><span class="n">withWorldLights</span><span class="p">(</span><span class="o">&amp;</span><span class="n">worldLights</span><span class="p">)</span>
                <span class="p">.</span><span class="n">withClearColor</span><span class="p">(</span><span class="nb">true</span><span class="p">,</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">})</span>
                <span class="p">.</span><span class="n">build</span><span class="p">();</span>

        <span class="c1">// draw geometry
</span>        <span class="n">renderPass</span><span class="p">.</span><span class="n">draw</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">modelMatrix</span><span class="p">,</span> <span class="n">materialPointer</span><span class="p">);</span>

        <span class="c1">// draw gui
</span>        <span class="n">ImGui</span><span class="o">::</span><span class="n">Text</span><span class="p">(</span><span class="s">"Dear ImGui says hello."</span><span class="p">);</span>

        <span class="n">r</span><span class="p">.</span><span class="n">swapWindow</span><span class="p">();</span>
        <span class="n">SDL_Delay</span><span class="p">(</span><span class="mi">16</span><span class="p">);</span>
    <span class="p">}</span>

</code></pre>

      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="c++">Code examples</a>
          </div>
      </div>
    </div>
  </body>
</html>
